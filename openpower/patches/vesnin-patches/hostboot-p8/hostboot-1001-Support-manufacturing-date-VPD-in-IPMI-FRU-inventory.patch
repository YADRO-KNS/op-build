From 3f1c78c43cf9610d0bb11e3e4d035a3f063b1781 Mon Sep 17 00:00:00 2001
From: Artem Senichev <a.senichev@yadro.com>
Date: Mon, 26 Nov 2018 13:58:46 +0300
Subject: [PATCH] Support manufacturing date VPD in IPMI FRU inventory

Backport of functionality from master branch (P9) to master-p8.
Original commits:
3d0fd427668ae9418f50d1432cceee3c95e794d6
1be038e7e43d6583bfdf145adfc0eef697e83c5d
by Matt Ploetz <maploetz@us.ibm.com>

Signed-off-by: Artem Senichev <a.senichev@yadro.com>
---
 src/include/usr/ipmi/ipmi_reasoncodes.H |   2 +
 src/include/usr/vpd/cvpdenums.H         |   1 +
 src/include/usr/vpd/pvpdenums.H         |   1 +
 src/usr/ipmi/ipmifruinv.C               | 174 +++++++++++++++++++++++-
 src/usr/ipmi/ipmifruinvprvt.H           |  18 +++
 src/usr/vpd/cvpd.H                      |   1 +
 src/usr/vpd/pvpd.H                      |   1 +
 7 files changed, 194 insertions(+), 4 deletions(-)

diff --git a/src/include/usr/ipmi/ipmi_reasoncodes.H b/src/include/usr/ipmi/ipmi_reasoncodes.H
index 970a69441..43444231d 100644
--- a/src/include/usr/ipmi/ipmi_reasoncodes.H
+++ b/src/include/usr/ipmi/ipmi_reasoncodes.H
@@ -37,6 +37,7 @@ namespace IPMI
         MOD_IPMIDCMI            = 0x04, // IPMI::sensor
         MOD_IPMIRT              = 0x05, // rt IPMI::send/IPMI::sendrecv
         MOD_IPMISRV_POSTEVENT   = 0x06, // IpmiRP::postEvent
+        MOD_IPMIFRU_INV         = 0x07, // IPMI:fruInventory
     };
 
     enum IPMIReasonCode
@@ -53,6 +54,7 @@ namespace IPMI
         RC_DCMI_CMD_FAILED              = IPMI_COMP_ID | 0x0a,
         RC_SENSOR_READING_NOT_AVAIL     = IPMI_COMP_ID | 0x0b,
         RC_GET_SENSOR_TYPE_CMD_FAILED   = IPMI_COMP_ID | 0x0c,
+        RC_INVALID_VPD_DATA             = IPMI_COMP_ID | 0x0e,
     };
 };
 
diff --git a/src/include/usr/vpd/cvpdenums.H b/src/include/usr/vpd/cvpdenums.H
index c26743140..91b891b3e 100644
--- a/src/include/usr/vpd/cvpdenums.H
+++ b/src/include/usr/vpd/cvpdenums.H
@@ -131,6 +131,7 @@ namespace CVPD
         pd6         = 0x44, //#6
         pd8         = 0x45, //#8
         pdY         = 0x46, //#Y
+        MB          = 0x47,
 
         // Last Keyword
         CVPD_LAST_KEYWORD,
diff --git a/src/include/usr/vpd/pvpdenums.H b/src/include/usr/vpd/pvpdenums.H
index 6bf004107..c648dcd8c 100644
--- a/src/include/usr/vpd/pvpdenums.H
+++ b/src/include/usr/vpd/pvpdenums.H
@@ -82,6 +82,7 @@ namespace PVPD
         VS         = 0x16,
         VZ         = 0x17,
         LX         = 0x18,
+        MB         = 0x19,
 
         // Last Keyword
         PVPD_LAST_KEYWORD,
diff --git a/src/usr/ipmi/ipmifruinv.C b/src/usr/ipmi/ipmifruinv.C
index 83459c575..12480ea15 100644
--- a/src/usr/ipmi/ipmifruinv.C
+++ b/src/usr/ipmi/ipmifruinv.C
@@ -40,6 +40,7 @@
 #include <assert.h>
 #include <pnor/pnorif.H>
 #include <console/consoleif.H>
+#include <ipmi/ipmi_reasoncodes.H>
 
 extern trace_desc_t * g_trac_ipmi;
 
@@ -524,6 +525,167 @@ void IpmiFruInv::setAreaSize(std::vector<uint8_t> &io_data, uint8_t i_offset)
     return;
 }
 
+static inline uint8_t bcd2_to_int(uint8_t bcd)
+{
+    return ((bcd >> 4) & 0xF) * 10 + (bcd & 0xF);
+}
+
+// Function to compute the correct data for the Mfg date/time section.
+// IPMI expects the time to be in seconds from 01/01/1996.
+errlHndl_t IpmiFruInv::formatMfgData(std::vector<uint8_t> i_mfgDateData,
+                                   uint32_t& o_mfgDate)
+{
+    errlHndl_t l_errl = NULL;
+
+    // MB keyword size is 8 hex bytes, throw an error if it is smaller so we
+    // don't do an invalid access.
+    if (i_mfgDateData.size() != 8)
+    {
+        /*@
+         *  @errortype
+         *  @moduleid       IPMI::MOD_IPMIFRU_INV
+         *  @reasoncode     IPMI::RC_INVALID_VPD_DATA
+         *  @userdata1      Size of vpd data
+         *
+         *  @devdesc        VPD data is invalid size
+         */
+        l_errl = new ERRORLOG::ErrlEntry(ERRORLOG::ERRL_SEV_INFORMATIONAL,
+                                          IPMI::MOD_IPMIFRU_INV,
+                                          IPMI::RC_INVALID_VPD_DATA,
+                                          i_mfgDateData.size());
+
+        TARGETING::Target* nodeTarget = NULL;
+        TARGETING::PredicateCTM nodeFilter(TARGETING::CLASS_ENC,
+                                           TARGETING::TYPE_NODE);
+        TARGETING::TargetRangeFilter nodeItr(
+            TARGETING::targetService().begin(),
+            TARGETING::targetService().end(),
+            &nodeFilter);
+
+        nodeTarget = *nodeItr;
+
+        // Callout out node since that is where the VPD lives
+        l_errl->addHwCallout(nodeTarget,
+                             HWAS::SRCI_PRIORITY_HIGH,
+                             HWAS::NO_DECONFIG,
+                             HWAS::GARD_NULL );
+    }
+    else
+    {
+        // Convert Centuries / Years / months / day / hour / minute / second
+        // into a uint64 representing number of minute since 1/1/96
+
+        // The vpd data is expected to be in this format VVCCYYmmDDHHMMSS
+        // Note that it is Binary Coded Decimal(BCD). Need to translate to int.
+        uint8_t century = bcd2_to_int(i_mfgDateData.at(1));
+        uint8_t year = bcd2_to_int(i_mfgDateData.at(2));
+        uint8_t month = bcd2_to_int(i_mfgDateData.at(3));
+        uint8_t day = bcd2_to_int(i_mfgDateData.at(4));
+        uint8_t hour = bcd2_to_int(i_mfgDateData.at(5));
+        uint8_t minute = bcd2_to_int(i_mfgDateData.at(6));
+
+        // Store number of days in a each month for computation of build date
+        const uint8_t daysInMonth[12] = { 31, 28, 31, 30, 31, 30,
+                                          31, 31, 30, 31, 30, 31 };
+
+        // Subtract year
+        uint8_t numOfYears = (century * 100 + year) - 1996;
+        // Subtract month
+        uint8_t numOfMonths = month - 1;
+        // Subtract day
+        uint16_t numOfDays = day - 1;
+
+        // Add the specific number of days for the months given
+        for (uint8_t i = 0; i < numOfMonths; i++)
+        {
+            numOfDays += daysInMonth[i];
+        }
+
+        // Add the number of days for the number of year given
+        numOfDays += (numOfYears * 365);
+
+        // Add a day for every leap year
+        // Check if we need to consider the current year
+        if (month <= 2)
+        {
+            // We don't need to consider this year for a leap year, as it
+            // wouldn't have happened yet. Decrement a year.
+            year = year - 1;
+        }
+
+        uint8_t numLeapYears = 0;
+        // For every year from 1996 until the build date year, check if it's a
+        // leap year
+        for(uint16_t i = 1996; i <= (century * 100 + year); i++)
+        {
+            // If the year is divisible by 4, its a leap year. Don't have to
+            // worry about centuries since the only possible century is 2000
+            // and it was a leap year.
+            if(i % 4 == 0)
+            {
+                numLeapYears++;
+            }
+        }
+
+        numOfDays += numLeapYears;
+
+        // Convert into minutes
+        o_mfgDate = (((numOfDays * 24) * 60) + (hour * 60) + minute);
+
+    }
+
+    return l_errl;
+}
+
+// Function to set the data for the Mfg date/time section.
+void IpmiFruInv::setMfgData(std::vector<uint8_t> &io_data,
+                                std::vector<uint8_t> &mfgDateData)
+{
+    errlHndl_t l_errl = NULL;
+    uint32_t mfgDate = 0;
+
+    // Pass mfgDateData vector to format function to get the minute integer
+    l_errl = formatMfgData(mfgDateData, mfgDate);
+    if (l_errl)
+    {
+        // MFG date isn't entierly necessary. Let's just delete and
+        // continue.
+        TRACFCOMP(g_trac_ipmi,"backplaneIpmiFruInv::buildBoardInfoArea - "
+            "Error from formatMfgData. Using default MFG Date/Time.");
+         io_data.push_back(0);
+         io_data.push_back(0);
+         io_data.push_back(0);
+         delete l_errl;
+    }
+    else
+    {
+        if(((mfgDate & 0xFF000000) >> 24) != 0)
+        {
+            // If there is data in these bits, we have exceeded the
+            // maximum time we can display (IPMI only takes in 3 bytes
+            // of hex, FFFFFF)
+            TRACFCOMP(g_trac_ipmi,"backplaneIpmiFruInv::buildBoardInfoArea "
+                "- Exeeded maximum allowed build date to display. Using "
+                "default MFG Date/Time.");
+            io_data.push_back(0);
+            io_data.push_back(0);
+            io_data.push_back(0);
+        }
+        else
+        {
+            // Convert mfgDate to hex
+            uint8_t l_leastSig = (mfgDate & 0x000000FF);
+            uint8_t l_middleSig = (mfgDate & 0x0000FF00) >> 8;
+            uint8_t l_mostSig = (mfgDate & 0x00FF0000) >> 16;
+
+            // Push data into io_data - least significant byte first
+            io_data.push_back(l_leastSig);
+            io_data.push_back(l_middleSig);
+            io_data.push_back(l_mostSig);
+        }
+    }
+}
+
 //##############################################################################
 isdimmIpmiFruInv::isdimmIpmiFruInv( TARGETING::TargetHandle_t i_target )
     :IpmiFruInv(i_target)
@@ -1093,10 +1255,14 @@ errlHndl_t backplaneIpmiFruInv::buildBoardInfoArea(
         //Set formatting data that goes at the beginning of the record
         preFormatProcessing(io_data, true);
 
-        //Set MFG Date/Time - Blank
-        io_data.push_back(0);
-        io_data.push_back(0);
-        io_data.push_back(0);
+        // Set Mfg Build date
+        // Grab VPD data into seperate data vector
+        std::vector<uint8_t> mfgDateData;
+        l_errl = addVpdData(mfgDateData, PVPD::OPFR, PVPD::MB, false, false);
+        if (l_errl) { break; }
+
+        // Pass that to the function that sets the Build date
+        setMfgData(io_data, mfgDateData);
 
         //Set Vendor Name - ascii formatted data
         l_errl = addVpdData(io_data, PVPD::OPFR, PVPD::VN, true);
diff --git a/src/usr/ipmi/ipmifruinvprvt.H b/src/usr/ipmi/ipmifruinvprvt.H
index 4132d58f6..3547a2ed8 100644
--- a/src/usr/ipmi/ipmifruinvprvt.H
+++ b/src/usr/ipmi/ipmifruinvprvt.H
@@ -141,6 +141,24 @@ class IpmiFruInv
      */
     void addDataToRecord(const std::vector<uint8_t>& i_data);
 
+    /**
+     * @brief Format inpuuted data to hex data that contains build date info
+     *
+     * @param[in] mfgDateData, MFG date data container from VPD
+     * @param[out] mfgDate, MFG date data value in minutes
+    */
+    errlHndl_t formatMfgData(std::vector<uint8_t> i_mfgDateData,
+                             uint32_t& o_mfgDate);
+
+    /**
+     * @brief Add product build date to IPMI fru record
+     *
+     * @param[in/out] data, The container to put build date in
+     * @param[in] mfgDateData, MFG date data container from VPD
+    */
+    void  setMfgData(std::vector<uint8_t> &io_data,
+                     std::vector<uint8_t> &i_mfgDateData);
+
     /**
      * @brief Builds the Internal Use Area Data Section
      * @param[in/out] data, The container to put intenral use area data in
diff --git a/src/usr/vpd/cvpd.H b/src/usr/vpd/cvpd.H
index 0ffbcc1ee..711f1a7f8 100644
--- a/src/usr/vpd/cvpd.H
+++ b/src/usr/vpd/cvpd.H
@@ -168,6 +168,7 @@ namespace CVPD
         { pd6, "#6" },
         { pd8, "#8" },
         { pdY, "#Y" },
+        { MB,  "MB" },
 
         // -------------------------------------------------------------------
         // DO NOT USE!!  This is for test purposes ONLY!
diff --git a/src/usr/vpd/pvpd.H b/src/usr/vpd/pvpd.H
index 32679507a..fb501a7d9 100644
--- a/src/usr/vpd/pvpd.H
+++ b/src/usr/vpd/pvpd.H
@@ -104,6 +104,7 @@ namespace PVPD
         { VS,  "VS" },
         { VZ,  "VZ" },
         { LX,  "LX" },
+        { MB,  "MB" },
 
         // -------------------------------------------------------------------
         // DO NOT USE!!  This is for test purposes ONLY!
-- 
2.19.1

